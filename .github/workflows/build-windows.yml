name: Build ScreenPipe for Windows

on:
  workflow_dispatch: # 允许你手动点击按钮触发构建

jobs:
  build:
    runs-on: windows-latest
    
    env:
      # 设置环境变量，对应文档中的 Step 4
      VCPKG_ROOT: "C:\\vcpkg"
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Bun (Frontend Runtime)
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup Rust (Backend Runtime)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Setup Python (For OpenMP script)
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install LLVM & Dependencies
        run: |
          choco install llvm -y
          choco install wget -y
          # GitHub Runner 自带 vcpkg，通常在 C:\vcpkg，我们需要利用它

      - name: Install FFmpeg via vcpkg (Cached)
        # 这一步最慢，尝试缓存 vcpkg 的构建结果
        id: vcpkg-cache
        uses: actions/cache@v3
        with:
          path: C:\vcpkg\installed
          key: ${{ runner.os }}-vcpkg-ffmpeg-${{ hashFiles('**/Cargo.lock') }}
      
      - name: Build FFmpeg if not cached
        if: steps.vcpkg-cache.outputs.cache-hit != 'true'
        run: |
          cd C:\vcpkg
          .\vcpkg.exe install ffmpeg:x64-windows
          .\vcpkg.exe integrate install

      - name: Set Environment Variables for Build
        # 对应文档 Step 4，必须显式设置到 GITHUB_ENV 中后续步骤才能读取
        run: |
          echo "PKG_CONFIG_PATH=C:\vcpkg\installed\x64-windows\lib\pkgconfig" >> $env:GITHUB_ENV
          echo "LIBCLANG_PATH=C:\Program Files\LLVM\bin" >> $env:GITHUB_ENV
          echo "C:\Program Files\LLVM\bin" >> $env:GITHUB_PATH

      - name: Setup Intel OpenMP DLLs (Documentation Step 6)
        run: |
          cd screenpipe
          # 直接运行文档中的 Python 逻辑，但为了方便，我们直接用 pip
          pip install intel-openmp
          
          # 创建目标目录
          $mkl_dir = "screenpipe-app-tauri\src-tauri\mkl"
          New-Item -ItemType Directory -Force -Path $mkl_dir
          
          # 找到 pip 安装的 dll 并复制 (简化版逻辑)
          $site_packages = pip show intel-openmp | Select-String "Location: " | ForEach-Object { $_.ToString().Split(" ")[1] }
          Copy-Item "$site_packages\tbb\*.dll" -Destination $mkl_dir -Recurse -Force -ErrorAction SilentlyContinue
          # 注意：上面的 Python 脚本逻辑在 Action 里可能因为路径问题比较脆弱
          # 如果这里报错，可能需要严格照搬文档的 Python 脚本保存为文件运行
          
      - name: Setup VC Redist (Documentation Step 7)
        run: |
          cd screenpipe
          $vcredist_dir = "screenpipe-app-tauri\src-tauri\vcredist"
          New-Item -ItemType Directory -Force -Path $vcredist_dir
          
          # 直接下载 dll (这里假设我们能直接拿到，或者忽略这一步依靠系统)
          # 为了稳妥，我们跳过下载安装包运行的步骤，直接依赖 Action 环境通常自带 VC++ 库
          # 如果运行报错缺 dll，则需要补全下载逻辑

      - name: Build Backend (Cargo)
        run: |
          cd screenpipe
          cargo build --release

      - name: Build Frontend & Bundle (Tauri)
        run: |
          cd screenpipe/screenpipe-app-tauri
          bun install
          bun tauri build

      - name: Upload Installer Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ScreenPipe-Installer
          path: |
            screenpipe/screenpipe-app-tauri/src-tauri/target/release/bundle/msi/*.msi
            screenpipe/screenpipe-app-tauri/src-tauri/target/release/bundle/nsis/*.exe
